:sdi-version: 0.9

= Simple Dependency Injection

SDI allows to extensively use Dependency Injection pattern in your application.
It achieves it without using annotations or reflections - just simple Java code.
Additionally, you can manage your service/application life cycle just by calling methods:
init(), start(), stop() and close() also by just calling these method on parent service.
You don't have any "configuration" for wiring up all classes - it is done in code.
All that takes about 600 lines of code.

Please let me know if you have any comments or suggestions about this project.

== How to start

Add dependency on SDI framework in your build file:

=== Gradle

[source,gradle,subs="attributes+"]
----
dependencies {
    compile 'net.igsoft:sdi:{sdi-version}'
}
----

=== Maven

[source,xml,subs="attributes+"]
----
<dependency>
    <groupId>net.igsoft</groupId>
    <artifactId>sdi</artifactId>
    <version>{sdi-version}</version>
</dependency>
----

SDI has only dependency on Guava and Logback.
Dependency on Guava is not critical, so I will consider to remove it.

== Concept and simple usage

The general concept is that for all classes which you want to put into this smallish DI framework
you prepare creator. Creator for some specific class has to inherit from abstract class Creator<>.
If the creation of the class is simple because that class only depends on other available classes,
it is possible to use AutoCreator<> but it is still the same concept, but a little bit more
automatization.

In the simplest case, class and its creator can look like below:

[source, java]
----
include::src/example/java/net/igsoft/sdi/SimpleCreatorExample.java[tags=config]
----

Right now it's not very interesting - just a little bit more code to write. The fun part starts when
we have more complicated classes.

Let's say that we have a class App which has a class Config as a dependency.

[source, java]
----
include::src/example/java/net/igsoft/sdi/SimpleCreatorExample.java[tags=app]
----

That way we have just applied dependency injection pattern in the simple case of two classes.
We have just delegated the work to InstanceCreator, which is responsible for finding the correct
creator.

But how we can use such classes?

Very simple: let's just create service which will keep information about all available instances:

[source, java]
----
include::src/example/java/net/igsoft/sdi/SimpleCreatorExample.java[tags=main]
----

That way we can get any instance of a class from the class hierarchy of App without worrying about
dependencies.


== Initialization of services

That's nice, but very often we need to initialize and later start at least some of the classes
in order to start our application. And when finishing application, we need to stop e.g. working
threads and finally release resources. That's still a lot of manual work.

Fortunately, there is a simple solution to this problem in SDI. It's just necessary to mark classes,
which should be initialized/started/stopped/closed with one of the two interfaces:
Manageable or ManageableBasic. ManageableBasic has two methods init() and close(). In many cases,
it is enough to initialize and shutdown instance of the class. In Manageable we can find
additionally two methods: start() and stop().

Let's see how it will work for another class: MqListener.

[source, java]
----
include::src/example/java/net/igsoft/sdi/LifecycleExample.java[tags=classes]
----

Now we can start an application from our main class:

[source, java]
----
include::src/example/java/net/igsoft/sdi/LifecycleExample.java[tags=main]
----

That way you have full control over application lifecycle.

== Automatic creators
In the above example we were creating App instance. In such a simple case coding creator is
quite a big overhead: you don't do anything interesting there - just passing other instances to the
App constructor. In such a case very helpful are automatic creators, which, as the name implies,
doesn't have to be implemented. How to use them? Below is above example rewritten with automatic
creators:

[source, java]
.AutoCreatorExample.java
----
include::src/example/java/net/igsoft/sdi/AutoCreatorExample.java[]
----

There is much less code, but you have still simplicity and configurability of a solution.
If you use auto creators you have to take into consideration that not every class can be instantiated
using auto creators. Notable exception are classes with many constructors or constructors not taking
only other known to the framework classes as a parameters. Also you can not pass creator parameters
to automatic creators.

== Parametrized creators

Sometimes we would like to reuse creators in different contexts. For example when we create MqReceiver
it can be used with different topics. Of course, we can add a dependency to configuration class to MqReceiverCreator
but then it will be difficult to reuse this creator in other application. That's why creators can be parametrized.

[source, java]
----
class ConfigCreatorParams extends ParametersBase {
    private final File file;

    public ConfigCreatorParams(File file) {
        super(false);
        this.file = file;
    }

    public File getFile() {
        return file;
    }

    @Override
    public String uniqueId() {
        return file.getName();
    }
}

class ConfigCreator extends Creator<Config, ConfigCreatorParams> {
    @Override
    public Config create(InstanceCreator instanceCreator, ConfigCreatorParams params) {
        File file = params.getFile();
        config = Config.createFromFile(fileName);
        return config;
    }
}
----

On the call side we use it like this:

[source, java]
----
class AppCreator extends Creator<App, LaunchType> {
    @Override
    public App create(InstanceCreator instanceCreator, LaunchType launchType) {
        ConfigCreatorParams params = new ConfigCreatorParams(new File("~/config.init"));
        Config config = instanceCreator.getOrCreate(Config.class, params);
        MqListener mqListener = instanceCreator.getOrCreate(MqListener.class);
        return new App(config, mqListener);
    }
}
----

== Default creators

Each creator can provide a set of default creators which can be used to create its dependencies.

For example if App creator needs for its work classes A, B and C, you can provide in it default creators for
some or all of mentioned classes. It is accomplished by overriding method:
[source, java]
----
List<Creator<?, ?>> defaultCreators()
----

and returning from it instances of creators.

[source, java]
----
class AppCreator extends Creator<App, LaunchType> {
    @Override
    public App create(InstanceCreator instanceCreator, LaunchType launchType) {
        A a = instanceCreator.getOrCreate(A.class);
        B b = instanceCreator.getOrCreate(B.class);
        C c = instanceCreator.getOrCreate(C.class);

        return new App(a, b, c);
    }

    @Override
    public List<Creator<?, ?>> defaultCreators() {
        return Lists.newArrayList(new ACreator(), new BCreator());
    }
}
----

That way we do not have to provide above creators during Service construction. When SDI finds that there is no
explicit creator, then it will take a default one.

Please notice that it is still possible to override default creator by setting different one
on Service setting level.

== Properties of SDI in a glance

* SDI manages only singleton instances of classes. If you need to create a bean on every request, just use
  standard Java mechanism: new Request() in listening code.

* SDI allows you to manage life cycle of application.

== What are the advantages of such an approach?

* Mild learning curve - you do not have to learn many new concepts on the start. Just leverage your
  Java knowledge. Well, it's even hard to say about "curve" - above information is pretty much all
  in this subject.

* Encourages writing easily testable code. To get easily testable code you should write simple constructors,
  (and creators take care about construction) and split your logic into construction and business logic
  (it's like that by design). Of course, you still have dependency injection.

* Does not pollute your application with annotations specific to DI framework.

* Does not force you to create programs according to strict, but not always fitting, rules imposed by the framework.
